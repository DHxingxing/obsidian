[[Iflytek/技术方案/多线程下 上下文信息丢失问题]]
## 问题背景


当我们创建标注任务之后，我们不可能让用户在一个线程下等待数据的加载。原因如下：

1. **数据量巨大**：单个标注任务可能涉及几万到几十万条资源数据
2. **网络调用耗时**：需要通过Feign调用外部数据集服务获取资源信息
3. **用户体验极差**：用户可能需要等待几分钟甚至更长时间
4. **系统风险高**：长时间占用HTTP连接，容易导致超时、连接池耗尽等问题

## 技术方案

所以我们引入了**Disruptor**在这里做异步信息的导入，**Redis Stream** 来做消息队列。

### Disruptor 的作用

**Disruptor** 作为高性能内存级事件处理框架，在我们的架构中承担以下职责：

1. **任务拆分**：将大批次资源导入任务（如10万条数据）快速拆分成多个小任务（如100个1000条的小批次）
2. **内存队列**：提供无锁、高吞吐的内存队列，避免传统队列的线程竞争
3. **多线程消费**：支持8个消费者线程并发处理，充分利用CPU资源
4. **异步解耦**：将HTTP请求线程与资源导入处理线程完全解耦

### Redis Stream 的作用

**Redis Stream** 作为持久化消息队列，在我们的架构中承担以下职责：

1. **持久化队列**：确保消息不丢失，即使系统重启也能继续处理
2. **消费确认机制**：支持ACK机制，确保每条消息都被正确处理
3. **流控保护**：控制对外部数据集服务的并发调用，避免过载
4. **可观测性**：可以通过Redis监控消息处理进度和堆积情况

### 架构协作流程

```
用户创建任务
    ↓
立即返回任务ID (500ms内)
    ↓
定时任务扫描 → Disruptor事件发布
    ↓
Disruptor消费者拆分任务 → Redis Stream消息
    ↓
Redis Stream消费者 → Feign调用外部服务
    ↓
数据写入本地数据库
    ↓
定时任务检查完成状态
```

### 技术优势

1. **性能优异**：
   - Disruptor提供内存级处理速度
   - Redis Stream提供高并发消息处理能力

2. **可靠性强**：
   - Disruptor确保内存事件不丢失
   - Redis Stream提供持久化保证

3. **可扩展性好**：
   - 消费者数量可配置调节
   - 支持水平扩展

4. **监控友好**：
   - 可以监控Disruptor的RingBuffer状态
   - 可以监控Redis Stream的消息堆积情况

### 配置参数

```yaml
system:
  load-resource:
    batch-buffer-size: 1048576    # Disruptor缓冲区大小(2^20)
    batch-consumer-size: 8        # Disruptor消费者数量
    batch-page-size: 1000         # 每批处理的资源数量
    consumer-core-threads: 5      # Redis Stream消费者核心线程数
    consumer-max-threads: 10      # Redis Stream消费者最大线程数
```

通过这种**双层异步架构**，我们实现了用户体验与系统性能的完美平衡，既保证了用户操作的即时响应，又确保了大批量数据处理的高效可靠。