## 1. 竞态条件 (Race Condition)

竞态条件指的是**两个或多个操作的最终执行结果，依赖于它们不受控制的执行时序**。当多个线程或进程在没有同步（如加锁）的情况下，并发地读写同一个共享资源时，就会发生竞态条件。

通俗地说，就像在十字路口没有红绿灯，两辆车都认为自己可以先通过，结果撞在了一起。谁先到、谁后到，这个无法预测的时序决定了最终是安全通过还是发生车祸。

#### 一个经典的例子：银行账户取款

假设一个银行账户有 1000 元。现在，你和你伴侣同时在两台不同的ATM机上取款，每人取 800 元。

**理想情况（串行执行）：**

1. 你的ATM机读取余额：1000元。
    
2. 计算：1000 - 800 = 200元。
    
3. 更新余额为 200元。交易成功。
    
4. 你伴侣的ATM机读取余额：200元。
    
5. 发现余额不足 800元，交易失败。 最终结果：账户余额 200元，总共只取出了 800元。**这是正确的。**
    

**发生竞态条件的情况（并发执行）：**

1. **时间点 T1**: 你的ATM机读取了账户余额：**1000元**。
    
2. **时间点 T2**: 在你完成取款前，系统切换，你伴侣的ATM机也读取了账户余额：**1000元**。（问题就出在这里！）
    
3. **时间点 T3**: 你的ATM机计算 1000 - 800 = 200，并将余额更新为 **200元**。
    
4. **时间点 T4**: 你伴侣的ATM机基于它在T2读取的旧数据进行计算 1000 - 800 = 200，并将余额更新为 **200元**。
    

最终结果：账户余额是 200元，但你们两人都成功取出了 800元（总共1600元）。银行损失了 600元。这就是典型的数据不一致问题。

#### 核心特征：

- **共享资源**：多个任务都在访问同一个对象、内存地址、文件或数据库记录。
    
- **并发访问**：访问是同时或在不可预测的交错顺序中发生的。
    
- **修改操作**：至少有一个任务在修改（写入）该资源。
    

#### 解决方案：

- **互斥锁 (Mutex)**：确保任何时候只有一个线程能访问该资源。
    
- **原子操作 (Atomic Operations)**：将“读取-修改-写入”这个过程变成一个不可分割的原子步骤。
    
- **事务 (Transactions)**：在数据库层面，将一系列操作打包，要么全部成功，要么全部失败。
    

---