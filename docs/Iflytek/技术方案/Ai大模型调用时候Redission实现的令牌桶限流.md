刚接到这个需求的时候，说实话，我对“令牌桶”的理解还停留在八股文的层面；至于调用大模型的方式，也只知道用 `curl` 敲命令行那一套。当我打开老项目的那一刻，眼前的画风简直是“代码地狱”：HTTP 请求头、请求体乱作一团，SSE 协议像是谜语人写的，WebSocket 配置更是云里雾里，简直要了我的老命。

幸好有几位哥们在关键时刻伸出援手，总算把需求给撸顺了。但事后回头想想，这事让我彻底明白了那句老话：**“学而不思则罔，思而不学则殆。”** 如果只是为了交付而写代码，不去深究背后的原理，那开发工作也就和拧螺丝没啥本质区别 —— 差不多就是个工具人罢了。

所以，这次需求虽然一度让我抓耳挠腮，但也正是这份“痛苦”，让我意识到：**光会调用 API，不懂协议和原理，是走不远的。**
## 1、策略工厂替换原来的名称匹配

我们要接入多个模型，就要实现多个配置类，老项目中面对多种模型的选择时候使用的竟然是（"中海油-海能大模型".equals(aiModelReq.getProjectAiModelConfigRequest().getModelName()),“大哥，你就拿名字和if-else 来做匹配啊，这真是想到什么写什么啊”)，因为每个模型的名字不一样，所以面对多个模型很自然的想到策略-工厂模式,不同的AI模型实现被封装在各自的策略类（`AiModelStragety`）中，`Service`层代码不需要关心具体模型的调用细节。这使得系统扩展性极强，增加新模型对现有代码无影响。
## 2、Redission 实现令牌桶限流

目前的服务肯定是在微服务的多机器上的，你肯定不能用基于JVM的令牌桶来做。目前项目中能满足的就是Redis了，所以我们用Redis 来做令牌桶。(这个问题其实就是有人会问你为什么不自己手写一个令牌桶算法，我在下面放个表格对比下就知道了。)

| 特性           | Redisson RSemaphore / RRateLimiter (令牌桶) | 自己手写一个限流器 (如 Java 的 Semaphore) |
|----------------|---------------------------------------------|---------------------------------------------|
| 场景           | 分布式系统（多台服务器）                    | 单机环境（只有一台服务器）                 |
| 工作原理       | 所有实例共享 Redis 中的计数器，全局可见      | 每个实例各自维护内存中的计数器，彼此不知  |
| 一致性         | 强一致性，全局统一限流                      | 无一致性，需要人为拆分额度，无法精准控制  |
| 可靠性         | 高：Redisson 使用 Lua 脚本保证原子性，稳定可靠 | 低：自己实现需要处理复杂分布式问题，容易出错 |
| 实现复杂度     | 极低：封装完善，一行代码搞定                 | 极高：需设计数据结构、编写 Lua 脚本等     |
| 维护成本       | 低：由 Redisson 官方持续维护                 | 高：自己写的逻辑需自己长期维护             |

起初我采用的是**滑动窗口限流**策略，设定例如“1 分钟内最多允许 10 个请求”这样的阈值。但在实际运行中，我发现它并不适合我们当前的业务需求，尤其是在大模型调用这种**请求耗时和资源消耗高度不均**的场景下，暴露出明显问题：

1. **不能体现任务的资源消耗差异**  
    大模型的调用耗时和资源占用与任务本身紧密相关。例如，让模型生成一篇 1 万字的小说和回答一个 “1 + 1 = ?” 所需的计算量完全不同。滑动窗口只是简单统计单位时间内的**请求次数**，无法感知请求的复杂度和对系统资源的实际占用。结果就是：轻量任务也会消耗掉限流额度，重任务可能被积压，从而导致系统资源利用率低甚至**出现等待但资源空闲**的情况。
    
2. **存在“突刺流量”风险，影响系统稳定性**  
    滑动窗口的另一个问题在于边界切换时的突刺效应。比如我们设置“1 分钟最多处理 5 个请求”：
    
    - 第 59 秒之前没有任何请求；
        
    - 第 60 秒瞬间来了 5 个请求，被全部放行；
        
    - 第 61 秒窗口滑动，又来了 5 个请求，同样被放行；
        
    
    结果是：在 2 秒内处理了 10 个请求，**限流规则形同虚设**，系统仍可能遭遇过载甚至被击穿。
    

综上所述，滑动窗口限流在大模型任务调度场景下显得不够灵活，既无法感知真实负载，也容易因为流量突刺造成风险。因此，我倾向于改用更适合此类场景的限流策略，比如**令牌桶算法**，它能更好地平滑请求速率，并允许一定程度的突发流量，同时也更易于与任务队列、动态信号量等资源感知型机制结合，实现更细粒度的调度控制。

我放弃了滑动窗口改使用信号量方案来实现令牌桶。
```java
// 获取分布式信号量
RSemaphore semaphore = redissonClient.getSemaphore(limiterKey);
```

- Redis数据结构：使用Redis的String类型存储信号量的许可数量
- 原子操作：基于Redis的DECR和INCR命令实现原子性的获取和释放
- 分布式一致性：通过Redis的原子操作保证多实例间的数据一致性

底层的实现可以分为初始化许可、获取许可、释放许可三步，三步是基于lua脚本操作的

想象一下，Redis 就是一个所有服务实例（你的应用部署在多个服务器上）都能访问的**中央数据中心**。Redisson 的所有操作，本质上都是在操作这个数据中心里的数据。

#### 1. 初始化许可 (`trySetPermits`)

当你第一次为某个模型（比如 `gpt-4`）设置限流时，会调用 `semaphore.trySetPermits(5)`。

- **开发者意图**：我想创建一个名为 `ai:limiter:gpt-4` 的信号量，并把它的总许可数（车位总数）设置为 `5`。这个操作只能成功一次。
    
- **Redisson 底层操作**：它不会傻傻地直接 `SET` 一个值。为了防止多个服务实例同时初始化导致冲突（竞态条件），它会向 Redis 发送一个类似 `SETNX` (SET if Not eXists) 的命令。
    
    **`SETNX "ai:limiter:gpt-4" 5`**
    
    这个 Redis 命令是**原子性**的。它表示：“只有当 `ai:limiter:gpt-4` 这个键**不存在**的时候，才将它设置为5”。
    
    - 第一个到达的实例执行 `SETNX`，成功设置了值，Redis 返回 `1`。
        
    - 后面紧跟着到达的其他实例再执行 `SETNX`，发现键已经存在了，操作失败，Redis 返回 `0`
    
    这样就完美保证了，无论多少个服务实例同时启动，这个信号量的总数只会被正确地初始化一次。
#### 2、获取许可

这是最关键的一步，也是最能体现 Lua 脚本威力的地方。

- **开发者意图**：我想从 `ai:limiter:gpt-4` 这个信号量里申请一个许可。如果当前许可数大于0，就给我一个，并把总数减一；如果等于0，就直接告诉我失败。整个过程必须是**一步完成**的，不能被打断。
    
- **为什么不能用多个 Redis 命令？** 如果你先用 `GET` 命令获取当前值，在你的应用代码里判断 `if (value > 0)`，然后再用 `DECR` 命令去减一。这个过程是**非原子**的。 在高并发下，可能发生这种情况：
    
    1. 服务A `GET` 到值为 `1`。
        
    2. 服务B 也在同时 `GET` 到值为 `1`。
        
    3. 服务A 判断 `1 > 0` 成立，执行 `DECR`，值变为 `0`。
        
    4. 服务B 也判断 `1 > 0` 成立，执行 `DECR`，值变为 `-1`。 结果，明明只有一个许可，却有两个服务同时获取成功，限流被“击穿”了。
        
- **Redisson 的 Lua 脚本解决方案**： Redisson 会将“检查并减少”这个逻辑，编写成一个 Lua 脚本，然后通过 `EVAL` 命令一次性发给 Redis 去执行。Redis 会保证整个脚本的执行过程是**原子**的，不会被任何其他命令插入。
    
    这个 Lua 脚本的逻辑可以简化成这样：
```lua
-- 脚本的参数：KEYS[1] 是信号量的键名, ARGV[1] 是想获取的许可数(通常是1)
local key = KEYS[1]
local permitsToAcquire = tonumber(ARGV[1])

-- 从 Redis 中获取当前许可数
local availablePermits = tonumber(redis.call('get', key))

-- 如果还有足够的许可
if availablePermits and availablePermits >= permitsToAcquire then
    -- 减少许可数
    redis.call('decrby', key, permitsToAcquire)
    -- 返回1代表成功
    return 1
else
    -- 许可数不够，返回0代表失败
    return 0
end
```

#### 3、释放许可
释放许可相对简单。

- **开发者意图**：我用完了一个许可，现在要把它还给 `ai:limiter:gpt-4`。
    
- **Redisson 底层操作**：同样是通过 Lua 脚本（或者一个简单的 `INCR` 命令）来完成。
    
    **`INCR "ai:limiter:gpt-4"`**
    
    `INCR` 命令也是原子的，它会安全地将键的值加一。所以，释放操作同样不会有并发问题。



## 补充知识：

 Semaphore 信号量在Java中的作用:
 
 在Java中，`Semaphore`（信号量）是 `java.util.concurrent` 并发包提供的一个非常重要的工具类。它的核心作用是**控制对特定资源或代码块的同时访问的线程数量**。
##### 主要方法和特性总结

1. **构造函数**：
    
    - `Semaphore(int permits)`：创建一个具有指定许可数量的信号量。
        
    - `Semaphore(int permits, boolean fair)`：可以指定是否为“公平模式”。公平模式下，等待的线程会按照 FIFO（先进先出）的顺序获得许可。非公平模式则允许“插队”，性能通常更高。
        
2. **核心方法**：
    
    - `void acquire()`: 获取一个许可，如果没有可用许可，则**阻塞**等待。
        
    - `void release()`: 释放一个许可，使其返回信号量。
        
    - `boolean tryAcquire()`: **非阻塞**地尝试获取一个许可。如果成功，返回 `true`；如果失败（没有可用许可），立即返回 `false`，线程不会等待。
        
    - `int availablePermits()`: 返回当前可用的许可数量。
        
3. **关键特性**：
    
    - **作用范围：单个 JVM**。Java 的 `Semaphore` 只能控制**同一个Java进程内部**的线程。它无法像 Redisson 的 `RSemaphore` 那样跨越多个服务器进行分布式协调。
        
    - **用途：它主要有两种工作模式：
	    - **作为互斥锁 (`new Semaphore(1)`)**：当许可数设置为1时，信号量的作用等同于一个锁，可以确保代码块在任何时刻最多只有一个线程执行，从而保护共享数据，保证线程安全。
		- **作为流量控制器 (`new Semaphore(N)`)**：当许可数设置为N（N > 1）时，它允许多达N个线程并发访问。这通常不用于保护共享变量，而是用于管理有限的资源池，如数据库连接、或限制对某个API的并发调用次数。