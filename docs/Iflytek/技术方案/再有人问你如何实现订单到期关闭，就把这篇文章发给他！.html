<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Iflytek/技术方案/再有人问你如何实现订单到期关闭，就把这篇文章发给他！" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">再有人问你如何实现订单到期关闭，就把这篇文章发给他！ | 不百科</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://DHxingxing.github.io/obsidian/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://DHxingxing.github.io/obsidian/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://DHxingxing.github.io/obsidian/docs/Iflytek/技术方案/再有人问你如何实现订单到期关闭，就把这篇文章发给他！"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="再有人问你如何实现订单到期关闭，就把这篇文章发给他！ | 不百科"><meta data-rh="true" name="description" content="前言"><meta data-rh="true" property="og:description" content="前言"><link data-rh="true" rel="icon" href="/obsidian/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://DHxingxing.github.io/obsidian/docs/Iflytek/技术方案/再有人问你如何实现订单到期关闭，就把这篇文章发给他！"><link data-rh="true" rel="alternate" href="https://DHxingxing.github.io/obsidian/docs/Iflytek/技术方案/再有人问你如何实现订单到期关闭，就把这篇文章发给他！" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://DHxingxing.github.io/obsidian/docs/Iflytek/技术方案/再有人问你如何实现订单到期关闭，就把这篇文章发给他！" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"再有人问你如何实现订单到期关闭，就把这篇文章发给他！","item":"https://DHxingxing.github.io/obsidian/docs/Iflytek/技术方案/再有人问你如何实现订单到期关闭，就把这篇文章发给他！"}]}</script><link rel="alternate" type="application/rss+xml" href="/obsidian/blog/rss.xml" title="不百科 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/obsidian/blog/atom.xml" title="不百科 Atom Feed"><link rel="stylesheet" href="/obsidian/assets/css/styles.3a069d1d.css">
<script src="/obsidian/assets/js/runtime~main.716c569d.js" defer="defer"></script>
<script src="/obsidian/assets/js/main.2eec64f1.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/obsidian/img/logo.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/obsidian/"><div class="navbar__logo"><img src="/obsidian/img/logo.svg" alt="logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/obsidian/img/logo.svg" alt="logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">不百科</b></a><a class="navbar__item navbar__link" href="/obsidian/docs/intro">文档</a><a class="navbar__item navbar__link" href="/obsidian/blog">博客</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/DHxingxing/obsidian" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="切换浅色/暗黑模式（当前为system mode）"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search (Meta+k)" aria-keyshortcuts="Meta+k"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/obsidian/docs/Iflytek/工作计划">Iflytek</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/obsidian/docs/Iflytek/工作计划">工作计划</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/obsidian/docs/Iflytek/工作计划7.7">工作计划7.7</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" tabindex="0" href="/obsidian/docs/Iflytek/技术方案/【最佳实践】Feign 泛型反序列化：告别 LinkedTreeMap 的终极解决方案">技术方案</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/obsidian/docs/Iflytek/技术方案/【最佳实践】Feign 泛型反序列化：告别 LinkedTreeMap 的终极解决方案">【最佳实践】Feign 泛型反序列化：告别 LinkedTreeMap 的终极解决方案</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/obsidian/docs/Iflytek/技术方案/再有人问你如何实现订单到期关闭，就把这篇文章发给他！">再有人问你如何实现订单到期关闭，就把这篇文章发给他！</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/obsidian/docs/Iflytek/技术方案/异步资源导入架构设计说明">异步资源导入架构设计说明</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/obsidian/docs/Iflytek/技术方案/数据库动态sql拼接问题！todo">数据库动态sql拼接问题！todo</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/obsidian/docs/Iflytek/技术方案/编写yml导致的参数增删如何影响实体类呢？">动态 YAML → ModelParams 映射全链路揭秘与最佳实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/obsidian/docs/Iflytek/技术方案/计算批次大小的证明">计算批次大小的证明</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/obsidian/docs/Iflytek/技术方案/重写Ai模块代码到新标注工具系统">重写Ai模块代码到新标注工具系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/obsidian/docs/Iflytek/技术方案/雪花算法导致的前端精度丢失问题">雪花算法导致的前端精度丢失问题</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/obsidian/docs/Iflytek/检查bug提示词：">检查bug提示词：</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/obsidian/docs/Java/AI/Rag">Java</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/obsidian/docs/daily/2025-06-30">daily</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/obsidian/docs/intro">我的知识库计划</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/obsidian/docs/源码/Redission 下的雪花算法">源码</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/obsidian/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Iflytek</span></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">技术方案</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">再有人问你如何实现订单到期关闭，就把这篇文章发给他！</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>再有人问你如何实现订单到期关闭，就把这篇文章发给他！</h1></header><h3 class="anchor anchorWithStickyNavbar_LWe7" id="前言">前言<a href="#前言" class="hash-link" aria-label="前言的直接链接" title="前言的直接链接">​</a></h3>
<p>在电商、支付等系统中，一般都是先创建订单（支付单），再给用户一定的时间进行支付，如果没有按时支付的话，就需要把之前的订单（支付单）取消掉。</p>
<p>这种类似的场景有很多，还有比如到期自动收货、超时自动退款、下单后自动发送 <a href="https://cloud.tencent.com/product/sms?from_column=20065&amp;from=20065" target="_blank" rel="noopener noreferrer">短信</a> 等等都是类似的业务问题。</p>
<p>本文就从这样的业务问题出发，探讨一下都有哪些技术方案，这些方案的实现细节，以及相关的优缺点都有什么？</p>
<p>因为本文要讲的内容比较多，涉及到11种具体方案，受篇幅限制，这篇文章主要是讲方案，不会涉及到具体的代码实现。 因为只要方案搞清楚了，代码实现不是难事儿。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="一被动关闭">一、被动关闭<a href="#一被动关闭" class="hash-link" aria-label="一、被动关闭的直接链接" title="一、被动关闭的直接链接">​</a></h3>
<p>在解决这类问题的时候，有一种比较简单的方式，那就是通过业务上的被动方式来进行关单操作。</p>
<p>简单点说，就是订单创建好了之后。我们系统上不做主动关单，什么时候用户来访问这个订单了，再去判断时间是不是超过了过期时间，如果过了时间那就进行关单操作，然后再提示用户。</p>
<p><img decoding="async" loading="lazy" src="https://developer.qcloudimg.com/http-save/yehe-admin/8a1420466b68f44a8da33510933d54f0.png" alt="" class="img_ev3q"></p>
<p>这种做法是最简单的，基本不需要开发定时关闭的功能，但是他的缺点也很明显，那就是如果用户一直不来查看这个订单，那么就会有很多脏数据冗余在 <a href="https://cloud.tencent.com/product/tencentdb-catalog?from_column=20065&amp;from=20065" target="_blank" rel="noopener noreferrer">数据库</a> 中一直无法被关单。</p>
<p>还有一个缺点，那就是需要在用户的查询过程中进行写的操作，一般写操作都会比读操作耗时更长，而且有失败的可能，一旦关单失败了，就会导致系统处理起来比较复杂。</p>
<p>所以， <strong>这种方案只适合于自己学习的时候用，任何商业网站中都不建议使用这种方案来实现订单关闭的功能。</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="二定时任务">二、定时任务<a href="#二定时任务" class="hash-link" aria-label="二、定时任务的直接链接" title="二、定时任务的直接链接">​</a></h3>
<p>定时任务关闭订单，这是很容易想到的一种方案。</p>
<p>具体实现细节就是我们通过一些调度平台来实现定时执行任务，任务就是去扫描所有到期的订单，然后执行关单动作。</p>
<p><img decoding="async" loading="lazy" src="https://developer.qcloudimg.com/http-save/yehe-admin/dd3a90e2166b60f1870131045ba0bfbf.png" alt="" class="img_ev3q"></p>
<p>这个方案的优点也是比较简单，实现起来很容易，基于Timer、ScheduledThreadPoolExecutor、或者像xxl-job这类调度框架都能实现，但是有以下几个问题：</p>
<p><strong>1、时间不精准。</strong> 一般定时任务基于固定的频率、按照时间定时执行的，那么就可能会发生很多订单已经到了超时时间，但是定时任务的调度时间还没到，那么就会导致这些订单的实际关闭时间要比应该关闭的时间晚一些。</p>
<p><strong>2、无法处理大订单量。</strong> 定时任务的方式是会把本来比较分散的关闭时间集中到任务调度的那一段时间，如果订单量比较大的话，那么就可能导致任务执行时间很长，整个任务的时间越长，订单被扫描到时间可能就很晚，那么就会导致关闭时间更晚。</p>
<p><strong>3、对数据库造成压力。</strong> 定时任务集中扫表，这会使得数据库IO在短时间内被大量占用和消耗，如果没有做好隔离，并且业务量比较大的话，就可能会影响到线上的正常业务。</p>
<p><strong>4、分库分表问题。</strong> 订单系统，一旦订单量大就可能会考虑分库分表，在分库分表中进行全表扫描，这是一个极不推荐的方案。</p>
<p>所以， <strong>定时任务的方案，适合于对时间精确度要求不高、并且业务量不是很大的场景中。如果对时间精度要求比较高，并且业务量很大的话，这种方案不适用。</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="三jdk自带的延迟队列">三、JDK自带的延迟队列<a href="#三jdk自带的延迟队列" class="hash-link" aria-label="三、JDK自带的延迟队列的直接链接" title="三、JDK自带的延迟队列的直接链接">​</a></h3>
<p>有这样一种方案，他不需要借助任何外部的资源，直接基于应用自身就能实现，那就是基于JDK自带的DelayQueue来实现。</p>
<p><code>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。</code></p>
<p>基于延迟队列，是可以实现订单的延迟关闭的，首先，在用户创建订单的时候，把订单加入到DelayQueue中，然后，还需要一个常驻任务不断的从队列中取出那些到了超时时间的订单，然后在把他们进行关单，之后再从队列中删除掉。</p>
<p>这个方案需要有一个线程，不断的从队列中取出需要关单的订单。一般在这个线程中需要加一个while(true)循环，这样才能确保任务不断的执行并且能够及时的取出超时订单。</p>
<p>使用DelayQueue实现超时关单的方案，实现起来简单，不须要依赖第三方的框架和类库，JDK原生就支持了。</p>
<p>当然这个方案也不是没有缺点的，首先，基于DelayQueue的话，需要把订单放进去，那如果订单量太大的话，可能会导致OOM的问题；另外，DelayQueue是基于JVM内存的，一旦机器重启了，里面的数据就都没有了。虽然我们可以配合数据库的持久化一起使用。而且现在很多应用都是集群部署的，那么集群中多个实例上的多个DelayQueue如何配合是一个很大的问题。</p>
<p>所以， <strong>基于JDK的DelayQueue方案只适合在单机场景、并且数据量不大的场景中使用，如果涉及到分布式场景，那还是不建议使用。</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="四netty的时间轮">四、Netty的时间轮<a href="#四netty的时间轮" class="hash-link" aria-label="四、Netty的时间轮的直接链接" title="四、Netty的时间轮的直接链接">​</a></h3>
<p>还有一种方式，和上面我们提到的JDK自带的DelayQueue类似的方式，那就是基于时间轮实现。</p>
<p>为什么要有时间轮呢？主要是因为DelayQueue插入和删除操作的平均时间复杂度——O(nlog(n))，虽然已经挺好的了，但是时间轮的方案可以将插入和删除操作的时间复杂度都降为O(1)。</p>
<p><code>时间轮可以理解为一种环形结构，像钟表一样被分为多个 slot。每个 slot 代表一个时间段，每个 slot 中可以存放多个任务，使用的是链表结构保存该时间段到期的所有任务。时间轮通过一个时针随着时间一个个 slot 转动，并执行 slot 中的所有到期任务。</code></p>
<p><img decoding="async" loading="lazy" src="https://developer.qcloudimg.com/http-save/yehe-admin/1814c6bb43eaea358ccec77e510a6fed.png" alt="" class="img_ev3q"></p>
<p>基于Netty的HashedWheelTimer可以帮助我们快速的实现一个时间轮，这种方式和DelayQueue类似，缺点都是基于内存、集群扩展麻烦、内存有限制等等。</p>
<p>但是他相比DelayQueue的话，效率更高一些，任务触发的延迟更低。代码实现上面也更加精简。</p>
<p>所以， <strong>基于Netty的时间轮方案比基于JDK的DelayQueue效率更高，实现起来更简单，但是同样的，只适合在单机场景、并且数据量不大的场景中使用，如果涉及到分布式场景，那还是不建议使用。</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="五kafka的时间轮">五、Kafka的时间轮<a href="#五kafka的时间轮" class="hash-link" aria-label="五、Kafka的时间轮的直接链接" title="五、Kafka的时间轮的直接链接">​</a></h3>
<p>既然基于Netty的时间轮存在一些问题，那么有没有其他的时间轮的实现呢？</p>
<p>还真有的，那就是Kafka的时间轮，Kafka内部有很多延时性的操作，如延时生产，延时拉取，延时数据删除等，这些延时功能由内部的延时操作管理器来做专门的处理，其底层是采用时间轮实现的。</p>
<p><img decoding="async" loading="lazy" src="https://developer.qcloudimg.com/http-save/yehe-admin/68ae407596ba44a995abf94f41b1d948.png" alt="" class="img_ev3q"></p>
<p>而且，为了解决有一些时间跨度大的延时任务，Kafka 还引入了层级时间轮，能更好控制时间粒度，可以应对更加复杂的定时任务处理场景；</p>
<p>Kafka 中的时间轮的实现是 TimingWheel 类，位于 kafka.utils.timer 包中。基于Kafka的时间轮同样可以得到O(1)时间复杂度，性能上还是不错的。</p>
<p><strong>基于Kafka的时间轮的实现方式，在实现方式上有点复杂，需要依赖kafka，但是他的稳定性和性能都要更高一些，而且适合用在分布式场景中。</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="六rocketmq延迟消息">六、RocketMQ延迟消息<a href="#六rocketmq延迟消息" class="hash-link" aria-label="六、RocketMQ延迟消息的直接链接" title="六、RocketMQ延迟消息的直接链接">​</a></h3>
<p>相比于Kafka来说，RocketMQ中有一个强大的功能，那就是支持延迟消息。</p>
<p><img decoding="async" loading="lazy" src="https://developer.qcloudimg.com/http-save/yehe-admin/cea3d693fb935ff90db400611acf5af9.png" alt="" class="img_ev3q"></p>
<p><code>延迟消息，当消息写入到Broker后，不会立刻被消费者消费，需要等待指定的时长后才可被消费处理的消息，称为延时消息。</code></p>
<p>有了延迟消息，我们就可以在订单创建好之后，发送一个延迟消息，比如20分钟取消订单，那就发一个延迟20分钟的延迟消息，然后在20分钟之后，消息就会被消费者消费，消费者在接收到消息之后，去关单就行了。</p>
<p>但是，RocketMQ的延迟消息并不是支持任意时长的延迟的，它只支持：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h这几个时长。（商业版支持任意时长）</p>
<p>可以看到，有了RocketMQ延迟消息之后，我们处理上就简单很多，只需要发消息，和接收消息就行了，系统之间完全解耦了。但是因为延迟消息的时长受到了限制，所以并不是很灵活。</p>
<p><strong>如果我们的业务上，关单时长刚好和RocketMQ延迟消息支持的时长匹配的话，那么是可以基于RocketMQ延迟消息来实现的。否则，这种方式并不是最佳的。</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="七rabbitmq死信队列">七、RabbitMQ死信队列<a href="#七rabbitmq死信队列" class="hash-link" aria-label="七、RabbitMQ死信队列的直接链接" title="七、RabbitMQ死信队列的直接链接">​</a></h3>
<p>延迟消息不仅在RocketMQ中支持，其实在RabbitMQ中也是可以实现的，只不过其底层是基于死信队列实现的。</p>
<p>当RabbitMQ中的一条正常的消息，因为过了存活时间（TTL过期）、队列长度超限、被消费者拒绝等原因无法被消费时，就会变成Dead Message，即死信。</p>
<p><img decoding="async" loading="lazy" src="https://developer.qcloudimg.com/http-save/yehe-admin/9ae074f3c54f8b0e69db9c13399b8e1d.png" alt="" class="img_ev3q"></p>
<p>当一个消息变成死信之后，他就能被重新发送到死信队列中（其实是交换机-exchange）。</p>
<p>那么基于这样的机制，就可以实现延迟消息了。那就是我们给一个消息设定TTL，然但是并不消费这个消息，等他过期，过期后就会进入到死信队列，然后我们再监听死信队列的消息消费就行了。</p>
<p>而且，RabbitMQ中的这个TTL是可以设置任意时长的，这就解决了RocketMQ的不灵活的问题。</p>
<p>但是，死信队列的实现方式存在一个问题，那就是可能造成队头阻塞，因为队列是先进先出的，而且每次只会判断队头的消息是否过期，那么，如果队头的消息时间很长，一直都不过期，那么就会阻塞整个队列，这时候即使排在他后面的消息过期了，那么也会被一直阻塞。</p>
<p>基于RabbitMQ的死信队列，可以实现延迟消息，非常灵活的实现定时关单，并且借助RabbitMQ的集群扩展性，可以实现高可用，以及处理大并发量。他的缺点第一是可能存在消息阻塞的问题，还有就是方案比较复杂，不仅要依赖RabbitMQ，而且还需要声明很多队列(exchange)出来，增加系统的复杂度</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="八rabbitmq插件">八、RabbitMQ插件<a href="#八rabbitmq插件" class="hash-link" aria-label="八、RabbitMQ插件的直接链接" title="八、RabbitMQ插件的直接链接">​</a></h3>
<p>其实，基于RabbitMQ的话，可以不用死信队列也能实现延迟消息，那就是基于rabbitmq_delayed_message_exchange插件，这种方案能够解决通过死信队列实现延迟消息出现的消息阻塞问题。但是该插件从RabbitMQ的3.6.12开始支持的，所以对版本有要求。</p>
<p><img decoding="async" loading="lazy" src="https://developer.qcloudimg.com/http-save/yehe-admin/2d67c63f6c616217d2a3e0da06d93718.png" alt="" class="img_ev3q"></p>
<p>这个插件是官方出的，可以放心使用，安装并启用这个插件之后，就可以创建x-delayed-message类型的队列了。</p>
<p>前面我们提到的基于私信队列的方式，是消息先会投递到一个正常队列，在TTL过期后进入死信队列。但是基于插件的这种方式，消息并不会立即进入队列，而是先把他们保存在一个基于Erlang开发的Mnesia数据库中，然后通过一个定时器去查询需要被投递的消息，再把他们投递到x-delayed-message队列中。</p>
<p><strong>基于RabbitMQ插件的方式可以实现延迟消息，并且不存在消息阻塞的问题，但是因为是基于插件的，而这个插件支持的最大延长时间是(2^32)-1 毫秒，大约49天，超过这个时间就会被立即消费。但是他基于RabbitMQ实现，所以在可用性、性能方便都很不错</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="九redis过期监听">九、Redis过期监听<a href="#九redis过期监听" class="hash-link" aria-label="九、Redis过期监听的直接链接" title="九、Redis过期监听的直接链接">​</a></h3>
<p>很多用过Redis的人都知道，Redis有一个过期监听的功能，</p>
<p>在 redis.conf 中，加入一条配置notify-keyspace-events Ex开启过期监听，然后再代码中实现一个KeyExpirationEventMessageListener，就可以监听key的过期消息了。</p>
<p>这样就可以在接收到过期消息的时候，进行订单的关单操作。</p>
<p><strong>这个方案不建议大家使用，是因为Redis官网上明确的说过，Redis并不保证Key在过期的时候就能被立即删除，更不保证这个消息能被立即发出。所以，消息延迟是必然存在的，随着数据量越大延迟越长，延迟个几分钟都是常事儿。</strong></p>
<p>而且，在Redis 5.0之前，这个消息是通过PUB/SUB模式发出的，他不会做持久化，至于你有没有接到，有没有消费成功，他不管。也就是说，如果发消息的时候，你的客户端挂了，之后再恢复的话，这个消息你就彻底丢失了。（在Redis 5.0之后，因为引入了Stream，是可以用来做延迟 <a href="https://cloud.tencent.com/product/message-queue-catalog?from_column=20065&amp;from=20065" target="_blank" rel="noopener noreferrer">消息队列</a> 的。）</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="十redis的zset">十、Redis的zset<a href="#十redis的zset" class="hash-link" aria-label="十、Redis的zset的直接链接" title="十、Redis的zset的直接链接">​</a></h3>
<p>虽然基于Redis过期监听的方案并不完美，但是并不是Redis实现关单功能就不完美了，还有其他的方案。</p>
<p><img decoding="async" loading="lazy" src="https://developer.qcloudimg.com/http-save/yehe-admin/100b854466442c7e4d5b9c453b1852d3.png" alt="" class="img_ev3q"></p>
<p>我们可以借助Redis中的有序集合——zset来实现这个功能。</p>
<p>zset是一个有序集合，每一个元素(member)都关联了一个 score，可以通过 score 排序来取集合中的值。</p>
<p>我们将订单超时时间的时间戳（下单时间+超时时长）与订单号分别设置为 score 和 member。这样redis会对zset按照score延时时间进行排序。然后我们再开启redis扫描任务，获取”当前时间 &gt; score”的延时任务，扫描到之后取出订单号，然后查询到订单进行关单操作即可。</p>
<p><strong>使用redis zset来实现订单关闭的功能的优点是可以借助redis的持久化、高可用机制。避免</strong> <strong>数据丢失</strong> <strong>。但是这个方案也有缺点，那就是在高并发场景中，有可能有多个消费者同时获取到同一个订单号，一般采用加分布式锁解决，但是这样做也会降低吞吐型。</strong></p>
<p>但是，在大多数业务场景下，如果幂等性做得好的，多个消费者取到同一个订单号也无妨。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="十一redisson">十一、Redisson<a href="#十一redisson" class="hash-link" aria-label="十一、Redisson的直接链接" title="十一、Redisson的直接链接">​</a></h3>
<p>上面这种方案看上去还不错，但是需要我们自己基于zset这种数据结构编写代码，那么有没有什么更加友好的方式？</p>
<p>有的，那就是基于Redisson。</p>
<p>Redisson是一个在Redis的基础上实现的框架，它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。</p>
<p><img decoding="async" loading="lazy" src="https://developer.qcloudimg.com/http-save/yehe-admin/42486a9d355343d228b0803198cf337a.png" alt="" class="img_ev3q"></p>
<p>Redission中定义了分布式延迟队列RDelayedQueue，这是一种基于我们前面介绍过的zset结构实现的延时队列，它允许以指定的延迟时长将元素放到目标队列中。</p>
<p>其实就是在zset的基础上增加了一个基于内存的延迟队列。当我们要添加一个数据到延迟队列的时候，redission会把数据+超时时间放到zset中，并且起一个延时任务，当任务到期的时候，再去zset中把数据取出来，返回给客户端使用。</p>
<p>大致思路就是这样的，感兴趣的大家可以看一看RDelayedQueue的具体实现。</p>
<p><strong>基于Redisson的实现方式，是可以解决基于zset方案中的并发重复问题的，而且还能实现方式也比较简单，稳定性、性能都比较高。</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h3>
<p>我们介绍了11种实现订单定时关闭的方案，其中不同的方案各自都有优缺点，也各自适用于不同的场景中。那我们尝试着总结一下：</p>
<p><strong>实现的复杂度上（包含用到的框架的依赖及部署）：</strong></p>
<p>Redission &gt; RabbitMQ插件 &gt; RabbitMQ死信队列 &gt; RocketMQ延迟消息 ≈ Redis的zset &gt; Redis过期监听 ≈ kafka时间轮 &gt; 定时任务 &gt; Netty的时间轮 &gt; JDK自带的DelayQueue &gt; 被动关闭</p>
<p><strong>方案的完整性：</strong></p>
<p>Redission ≈ RabbitMQ插件 &gt; kafka时间轮 &gt; Redis的zset ≈ RocketMQ延迟消息 ≈ RabbitMQ死信队列 &gt; Redis过期监听 &gt; 定时任务 &gt; Netty的时间轮 &gt; JDK自带的DelayQueue &gt; 被动关闭</p>
<p>不同的场景中也适合不同的方案：</p>
<ul>
<li>
<p>自己玩玩：被动关闭</p>
</li>
<li>
<p>单体应用，业务量不大：Netty的时间轮、JDK自带的DelayQueue、定时任务</p>
</li>
<li>
<p>分布式应用，业务量不大：Redis过期监听、RabbitMQ死信队列、Redis的zset、定时任务</p>
</li>
<li>
<p>分布式应用，业务量大、并发高：Redission、RabbitMQ插件、kafka时间轮、RocketMQ延迟消息</p>
</li>
</ul>
<p>总体考虑的话，考虑到成本，方案完整性、以及方案的复杂度，还有用到的第三方框架的流行度来说， <strong>个人比较建议优先考虑Redission+Redis、RabbitMQ插件、Redis的zset、RocketMQ延迟消息等方案。</strong></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/DHxingxing/obsidian/edit/main/docs/Iflytek/技术方案/再有人问你如何实现订单到期关闭，就把这篇文章发给他！.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/obsidian/docs/Iflytek/技术方案/【最佳实践】Feign 泛型反序列化：告别 LinkedTreeMap 的终极解决方案"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">【最佳实践】Feign 泛型反序列化：告别 LinkedTreeMap 的终极解决方案</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/obsidian/docs/Iflytek/技术方案/异步资源导入架构设计说明"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">异步资源导入架构设计说明</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#前言" class="table-of-contents__link toc-highlight">前言</a></li><li><a href="#一被动关闭" class="table-of-contents__link toc-highlight">一、被动关闭</a></li><li><a href="#二定时任务" class="table-of-contents__link toc-highlight">二、定时任务</a></li><li><a href="#三jdk自带的延迟队列" class="table-of-contents__link toc-highlight">三、JDK自带的延迟队列</a></li><li><a href="#四netty的时间轮" class="table-of-contents__link toc-highlight">四、Netty的时间轮</a></li><li><a href="#五kafka的时间轮" class="table-of-contents__link toc-highlight">五、Kafka的时间轮</a></li><li><a href="#六rocketmq延迟消息" class="table-of-contents__link toc-highlight">六、RocketMQ延迟消息</a></li><li><a href="#七rabbitmq死信队列" class="table-of-contents__link toc-highlight">七、RabbitMQ死信队列</a></li><li><a href="#八rabbitmq插件" class="table-of-contents__link toc-highlight">八、RabbitMQ插件</a></li><li><a href="#九redis过期监听" class="table-of-contents__link toc-highlight">九、Redis过期监听</a></li><li><a href="#十redis的zset" class="table-of-contents__link toc-highlight">十、Redis的zset</a></li><li><a href="#十一redisson" class="table-of-contents__link toc-highlight">十一、Redisson</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/obsidian/docs/intro">快速开始</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://discord.gg/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/obsidian/blog">博客</a></li><li class="footer__item"><a href="https://github.com/DHxingxing/obsidian" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 DHxingxing. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>